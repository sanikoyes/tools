.TH "al_calculate_arc" "3" "" "Allegro reference manual" ""
.SH NAME
.PP
al_calculate_arc \- Allegro 5 API
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <allegro5/allegro_primitives.h>

void\ al_calculate_arc(float*\ dest,\ int\ stride,\ float\ cx,\ float\ cy,
\ \ \ float\ rx,\ float\ ry,\ float\ start_theta,\ float\ delta_theta,\ float\ thickness,
\ \ \ int\ num_points)
\f[]
.fi
.SH DESCRIPTION
.PP
When \f[C]thickness\ <=\ 0\f[] this function computes positions of
\f[C]num_points\f[] regularly spaced points on an elliptical arc.
When \f[C]thickness\ >\ 0\f[] this function computes two sets of points,
obtained as follows: the first set is obtained by taking the points
computed in the \f[C]thickness\ <=\ 0\f[] case and shifting them by
\f[C]thickness\ /\ 2\f[] outward, in a direction perpendicular to the
arc curve.
The second set is the same, but shifted \f[C]thickness\ /\ 2\f[] inward
relative to the arc.
The two sets of points are interleaved in the destination buffer (i.e.
the first pair of points will be collinear with the arc center, the
first point of the pair will be farther from the center than the second
point; the next pair will also be collinear, but at a different angle
and so on).
.PP
The destination buffer \f[C]dest\f[] is interpreted as a set of
regularly spaced pairs of floats, each pair holding the coordinates of
the corresponding point on the arc.
The two floats in the pair are adjacent, and the distance (in bytes)
between the addresses of the first float in two successive pairs is
\f[C]stride\f[].
For example, if you have a tightly packed array of floats with no spaces
between pairs, then \f[C]stride\f[] will be exactly
\f[C]2\ *\ sizeof(float)\f[].
.PP
Example with \f[C]thickness\ <=\ 0\f[]:
.IP
.nf
\f[C]
const\ int\ num_points\ =\ 4;
float\ points[num_points][2];
al_calculate_arc(&points[0][0],\ 2\ *\ sizeof(float),\ 0,\ 0,\ 10,\ 10,\ 0,\ ALLEGRO_PI\ /\ 2,\ 0,\ num_points);

assert((int)points[0][0]\ ==\ 10);
assert((int)points[0][1]\ ==\ 0);

assert((int)points[num_points\ \-\ 1][0]\ ==\ 0);
assert((int)points[num_points\ \-\ 1][1]\ ==\ 10);
\f[]
.fi
.PP
Example with \f[C]thickness\ >\ 0\f[]:
.IP
.nf
\f[C]
const\ int\ num_points\ =\ 4;
float\ points[num_points\ *\ 2][2];
al_calculate_arc(&points[0][0],\ 2\ *\ sizeof(float),\ 0,\ 0,\ 10,\ 10,\ 0,\ ALLEGRO_PI\ /\ 2,\ 2,\ num_points);

assert((int)points[0][0]\ ==\ 11);
assert((int)points[0][1]\ ==\ 0);
assert((int)points[1][0]\ ==\ 9);
assert((int)points[1][1]\ ==\ 0);

assert((int)points[(num_points\ \-\ 1)\ *\ 2][0]\ ==\ 0);
assert((int)points[(num_points\ \-\ 1)\ *\ 2][1]\ ==\ 11);
assert((int)points[(num_points\ \-\ 1)\ *\ 2\ +\ 1][0]\ ==\ 0);
assert((int)points[(num_points\ \-\ 1)\ *\ 2\ +\ 1][1]\ ==\ 9);
\f[]
.fi
.PP
\f[I]Parameters:\f[]
.IP \[bu] 2
dest \- The destination buffer
.IP \[bu] 2
stride \- Distance (in bytes) between starts of successive pairs of
points
.IP \[bu] 2
cx, cy \- Center of the arc
.IP \[bu] 2
rx, ry \- Radii of the arc
.IP \[bu] 2
start_theta \- The initial angle from which the arc is calculated in
radians
.IP \[bu] 2
delta_theta \- Angular span of the arc in radians (pass a negative
number to switch direction)
.IP \[bu] 2
thickness \- Thickness of the arc
.IP \[bu] 2
num_points \- The number of points to calculate
.SH SEE ALSO
.PP
al_draw_arc(3), al_calculate_spline(3), al_calculate_ribbon(3)
